//! Lesbar provides non-empty string types that must represent legible text.
//!
//! At time of writing, `rustdoc` ignores input type parameters in the "Methods from
//! `Deref<Target = _>`" section. For types that implement `Deref<Target = NonEmpty<_>>`, **the API
//! documentation may be misleading** and list all methods of [`NonEmpty`] regardless of its input
//! type parameter. This is mostly a problem for types that dereference to [`Str1`], such as
//! [`Text`]. See [this `rustdoc` bug](https://github.com/rust-lang/rust/issues/24686).
//!
//! # Integrations and Cargo Features
//!
//! Lesbar supports `no_std` environments and provides features for integrating as needed with
//! [`alloc`]. By default, the `alloc` feature is enabled for complete support of the standard
//! library.
//!
//! The following table summarizes supported Cargo features and integrations.
//!
//! | Feature     | Default | Primary Dependency | Description                                         |
//! |-------------|---------|--------------------|-----------------------------------------------------|
//! | `alloc`     | Yes     | [`alloc`]          | Legible string buffer types like [`TextBuf`].       |
//! | `serde`     | No      | [`serde`]          | De/serialization of legible strings with [`serde`]. |
//!
//! [`serde`]: https://crates.io/crates/serde
//! [`Str1`]: mitsein::str1::Str1
//! [`Text`]: crate::text::Text
//! [`TextBuf`]: crate::text::TextBuf

// SAFETY: This crate is somewhat more conservative than the `mitsein` crate regarding unsafe code.
//         While it uses unsafe code, this is only done when strictly necessary (mostly for
//         conversions) and invariants are asserted. This is why unchecked functions are **not**
//         unsafe: the invariants of these functions are not assumed in other functions.

#![cfg_attr(docsrs, feature(doc_cfg))]
// LINT: The serialization implementations for `Text<T>` rely on conversions between
//       `Serde<Text<T>>` and `Text<T>`. These implementations require `Text<T>: Clone`, which
//       implies `T: Sized` (because `Clone` requires `Sized`). This is expected, because
//       serialization of `Text<T>` where `T` is unsized is not possible. These implementations
//       apply only to `Sized` and owning `Text` types, such as `Text<String>`.
//
//       This attribute is applied to the crate, because it is not possible to apply it to the
//       implementations generated by procedural macros.
#![cfg_attr(feature = "serde", expect(clippy::needless_maybe_sized))]
#![no_std]

#[cfg(feature = "alloc")]
extern crate alloc;

extern crate self as lesbar;

mod serde;

pub mod text;

pub mod prelude {
    //! Re-exports of recommended APIs and extension traits.

    pub use crate::text::Text;
    pub use crate::StrExt as _;
    #[cfg(feature = "alloc")]
    pub use {
        crate::grapheme::CowGraphemeExt as _,
        crate::text::{CowTextExt as _, TextBuf},
    };
}

#[cfg(feature = "serde")]
use ::serde::{Deserialize, Serialize};
#[cfg(feature = "alloc")]
use alloc::borrow::ToOwned;
use core::error::Error;
use core::fmt::{self, Debug, Display, Formatter};
use mitsein::NonEmpty;

#[cfg(feature = "serde")]
use crate::serde::Serde;

pub use lesbar_macros::{str1, text};
pub use lesbar_text::{grapheme, iter, RuneError, StrExt};

const ILLEGIBLE_ERROR_MESSAGE: &str = "failed to construct text: no legible content";

// TODO: Implement `From<mitsein::EmptyError<_>>`.
#[derive(Clone, Copy, Eq, Hash, PartialEq)]
pub struct IllegibleError<T> {
    illegible: T,
}

impl<T> IllegibleError<T> {
    fn from_illegible(illegible: T) -> Self {
        IllegibleError { illegible }
    }

    pub fn into_illegible(self) -> T {
        self.illegible
    }

    fn map<U, F>(self, f: F) -> IllegibleError<U>
    where
        F: FnOnce(T) -> U,
    {
        IllegibleError {
            illegible: f(self.illegible),
        }
    }

    pub fn take(self) -> (T, IllegibleError<()>) {
        (self.illegible, IllegibleError::from_illegible(()))
    }

    pub fn take_and_drop(self) -> IllegibleError<()> {
        self.take().1
    }

    pub fn as_illegible(&self) -> &T {
        &self.illegible
    }
}

impl<T> IllegibleError<&'_ T> {
    #[cfg(feature = "alloc")]
    #[cfg_attr(docsrs, doc(cfg(feature = "alloc")))]
    pub fn into_owning(self) -> IllegibleError<T::Owned>
    where
        T: ToOwned,
    {
        IllegibleError::from_illegible(self.illegible.to_owned())
    }
}

impl<T> Debug for IllegibleError<T> {
    fn fmt(&self, formatter: &mut Formatter<'_>) -> fmt::Result {
        formatter
            .debug_struct("IllegibleError")
            .finish_non_exhaustive()
    }
}

impl<T> Display for IllegibleError<T> {
    fn fmt(&self, formatter: &mut Formatter<'_>) -> fmt::Result {
        write!(formatter, "{ILLEGIBLE_ERROR_MESSAGE}")
    }
}

impl<T> Error for IllegibleError<T> {}

#[cfg_attr(
    feature = "serde",
    derive(::serde_derive::Deserialize, ::serde_derive::Serialize)
)]
#[cfg_attr(
    feature = "serde",
    serde(
        bound(
            deserialize = "Self: TryFrom<Serde<T>, Error = IllegibleError<T>>, \
                           T: Deserialize<'de>,",
            serialize = "T: Clone + Serialize,",
        ),
        try_from = "Serde<T>",
        into = "Serde<NonEmpty<T>>",
    )
)]
// Though this type contains a `NonEmpty<T>` rather than a `T`, this `derive` is correct, since
// `NonEmpty` also implements these traits with bounds on `T`.
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Legible<T>
where
    T: ?Sized,
{
    text: NonEmpty<T>,
}

impl<T> AsRef<T> for Legible<T> {
    fn as_ref(&self) -> &T {
        self.text.as_ref()
    }
}

#[cfg(test)]
mod tests {}
